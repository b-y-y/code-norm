1.一个实体只有一个紧凑的职责
    1.1.一次只解决一个问题，给每个实体（变量，函数，类，命名空间，模块和库）赋予一个定义良好的职责。随着实体变大，其职责范围相应扩大，但其职责不应发散。
    1.2.用较小的底层抽象来构建高层抽象。用几个简单的功能实现复杂功能。这往往比反其道而行简单。
2.正确，简单和清晰优先
    2.1使一个正确的程序变快要比使一个快速的程序正确简单
    2.2.使用命名变量而非临时变量作为构造函数的参数，这可以避免潜在的声明二义性。
3.编程中应知道何时和如何考虑可伸缩性。
    3.1.使用灵活的动态分配的数组，不要使用固定大小的数组。
    3.2.优先使用尽可能快的算法，比如线性算法，避免使用复杂度高于线性复杂度的算法。
4.尽量减少全局和共享数据
    4.共享数据会增加耦合度，降低可维护性。
5.隐藏信息
    5.1不要公开抽象实体的内部信息。
    5.2信息隐藏增加的代码实现的弹性，为以后的扩展和优化留下了空间，并降低了代码维护的难度。
6.确保资源为对象所拥有，使用显式的RAII 和智能指针。
    6.1.防止资源泄露
    6.2.异常安全
    6.3.永远不要在一条语句中分配一个以上的资源。
    6.4.实现RAII时，小心确认copy constructor and copy operator(assign operator)
7.宁要编译和链接错误，也不要运行时错误
    7.1.静态检查与控制流和数据无关，一般可信度更高
    7.2.静态表示的模型更可靠
    7.3.静态检查不会带来运行时开销
8.积极使用const
    8.1.值传递参数请勿使用const
    8.2注意const的深度
9.避免使用宏
    9.1.宏忽略作用域，无视类型系统，无视所有的语言特性和规则，只是简单的文本替换，在预处理阶段完成（此时c++ 的语法和语义规则都还不起作用）
    9.2.宏仅能理解C语言的小括号和方括号，并将其进行匹配。因此在宏中传入模板的实例是错误的。
10.使用可搜索的常值变量代替字面量
    10.1.使用有意义命名的常值变量可以帮助快速读懂程序，避免混淆。
11.尽可能局部的声明变量
    11.1.变量的生存期越短越好。
    11.2.常量不添加状态，因此不在此范围内
    11.3.变量的生存期过长会使程序变得难以理解和维护，其名字会污染上下文，且不能保证一定被恰当地初始化。
12.定义变量时就进行初始化
    12.1.用函数替代复杂的计算流：将复杂的计算逻辑封装成函数。
    12.2.总是初始化数组：Type arr[size]={0};
13.避免函数过长，避免嵌套过深
    13.1.函数有且只有一个职责
    13.2.不要重复代码
    13.2.优先使用&&代替连续嵌套
    13.3.优先使用标准算法
14.避免跨编译单元的初始化依赖
    14.1.不同编译单元的对象其初始化顺序是未定义的。
15.尽量减少定义性依赖，避免依赖循环
    15.1.优先使用前置声明（forward declaration）代替include
    15.2.只有需要知道对象大小，调用对象成员时才需要对象的完整定义，否则都可以使用前置声明。
    15.3.循环依赖:即循环引用，多个类之间互相持有对方，这将导致它们无法被单独使用
    15.4.只要类处于同一模块，一块测试，一块发布，循环依赖就是可以接受的。
16.头文件应该保证其能单独编译，为此它应包含需要的头文件
17.头文件应该编写内部包含保护符，避免重复包含。
    17.1
    {
        #ifndef filename.h
            #define filename.h
            fine content
        #endif
    }
18.正确地选择函数参数的形式
    18.1.内置类型等复制开销较低的read-only参数优先值传递。
    18.2.始终用const来修饰read-only 的指针或引用
    18.3.优先用const 引用取得UDT的read-only 参数
    18.4.如果函数需要参数的副本，则考虑值传递。
    18.5.如果是可选的modified的参数，可以考虑使用指针.
    18.6.如果是必须的modified的参数，使用引用传递.
19.保持重载操作符的自然语义。
    19.1.对于值类型不确定语义时请按照int去做.
    19.2.如果语义可能使人有异议，请使用具名函数代替操作符重载.
20.优先使用算数操作符和赋值操作符的标准形式。
    20.1.定义二元操作符时也应定义其赋值形式,例如:a+ b -->a+=b
    20.2.优先使用赋值形式实现一般形式（a×=b --> a * b），除非操作符需要显著改变其左值。
21.避免重载&&,||和,(逗号)
    21.1.&& 和|| 遵循短路求值特性，（，comma）遵循从左到右顺序求值特性，而我们重载后无法保证能保持这种特性，所以这几个操作符不宜重载。
    21.2.operator that can not be overloaded:(.(dot),.*(dot*),::(scope),? :(ternary),sizeof)
22.不要编写依赖于函数求值顺序的代码。
    22.1.函数参数的求值顺序是不确定的，因此不要编写依赖于参数求值顺序的程序。